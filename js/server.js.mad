var System = require("sys");
var HTTP = require("http");
var WebSocketServer = require("C:/Program Files/nodejs/node_modules/websocket").server;
//var Game = require("G:\bumper\bootstrap");

var Frame = 0;
var FramesPerGameStateTransmission = 3;
var MaxConnections = 10;
var Connections = {};

// Creates an HTTP server that will respond with a simple blank page when accessed.
var HTTPServer = HTTP.createServer(
			function(Request, Response)
			{
				Response.writeHead(200, { "Content-Type": "text/plain" });
				Response.end();
			}
			);

// Starts the HTTP server on port 9001.
HTTPServer.listen(9001, function() { System.log("Listening for connections on port 9001"); });

// Creates a WebSocketServer using the HTTP server just created.
var Server = new WebSocketServer(
			{
				httpServer: HTTPServer,
				closeTimeout: 2000
			}
			);
			
// When a client connects...
Server.on("request",
			function(Request)
			{
				if (ObjectSize(Connections) >= MaxConnections)
				{
					Request.reject();
					return;
				}
				
				var Connection = Request.accept(null, Request.origin);
				Connection.IP = Request.remoteAddress;
				
				// Assign a random ID that hasn't already been taken.
				do { Connection.ID = Math.floor(Math.random() * 100000) } while (Connection.ID in Connections);
				Connections[Connection.ID] = Connection;
				
				
				Connection.on("message",
					function(Message)
					{
						// All of our messages will be transmitted as unicode text.
						if (Message.type == "utf8")
							HandleClientMessage(Connection.ID, Message.utf8Data);
							System.log("last edited for connection is " + Connections[Connection.ID].Page);
					}
					);
					
				Connection.on("close",
					function()
					{
						HandleClientClosure(Connection.ID);
					}
					);
				
				System.log("Logged in " + Connection.IP + "; currently " + ObjectSize(Connections) + " users.");
			}
			);

function HandleClientClosure(ID)
{
	if (ID in Connections)
	{
		System.log("Disconnect from " + Connections[ID].IP);
		delete Connections[ID];
	}
}

function HandleClientMessage(ID, Message)
{
	// Check that we know this client ID and that the message is in a format we expect.
	if (!(ID in Connections)) return;
	System.log("last edited for connection " + ID + " is " + Connections[ID].Page);
	try { Message = JSON.parse(Message); }
	catch (Err) { return; }
	//if (!("Type" in Message && "Data" in Message)) return;
	//SendGameState();
	// Handle the different types of messages we expect.
	var C = Connections[ID];
	if ("Type" in Message) {
	switch (Message.Type)
	{
		// Handshake.
        case "HI":
            //New user: update his page with other user information
			SendGameState();
			break;

			default:
	}
	}
	else {
	System.log("last edited for connection " + ID + " is " + C.Page);
	C.Page = Message.Page;
	   SendGameState();
	}
}

function SendGameState()
{
	var lastEditedPage = {
        rows: {},
        name: "",
        lastEdited: -1
    };
	
	// Collect all the page objects to be sent out to the clients
	for (var ID in Connections)
	{
		// Some users may not have Page objects yet (if they haven't done the handshake)
		var C = Connections[ID];
		if (!C.Page)
            continue;
System.log("last edited for connection " + ID + " is " + C.Page.lastEdited);
        if (lastEditedPage.lastEdited <= C.Page.lastEdited){
            lastEditedPage = C.Page;
        }
	}
	
	// Go through all of the connections and send them the latest version of the page
    for (var ID in Connections){
        Connections[ID].sendUTF(JSON.stringify({ Page: lastEditedPage }));
    }
}
			
function ObjectSize(Obj)
{
	var Size = 0;
	for (var Key in Obj)
		if (Obj.hasOwnProperty(Key))
			Size++;
			
	return Size;
}